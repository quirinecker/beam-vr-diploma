\section{Hardware}

\subsection{Grundlagen}
\label{sec:basics}

\subsubsection{Arten von VR Headsets}
\label{sec:vr-headset-types}

Bei VR Headsets werden grundsätzlich drei verschiedene Arten unterschieden:

\begin{itemize}
    \item Tethered Headsets
    \item Standalone Headsets
    \item Smartphone und Handheld Headsets
\end{itemize}

In Folge werden diese Arten kurz beschrieben, sodass die beschreibungen von der Technologien verstanden werden können.
Für eine genauere beschreibung dieses Themas wird auf~\cite{ANIWAA_TEAM_2021} verwiesen.

\emph{Tethered VR Headsets} müssen immer mit einem Computer verbunden sein, weil die VR-Applikation ausschließlich auf dem Computer läuft.
Die Brille hat dabei einerseits die Funktion die vom Computer gerenderten daten darzustellen und andererseits Positionsdaten an den Computer zurückzusenden, damit diese in der Applikationslogik verwendet werden können, um zukünftige Bilddaten zu rendern.

Bei \emph{Standalone VR Headsets} ist in der Brille ein Computer integriert, auf welchem die VR Applikation läuft.
Der Computer dient ausschließlich aus Entwicklungsplattform und die fertigen Applikationen müssen auf die Brille heruntergeladen werden.

Im Falle des \emph{Smartphone VR Headsets} läuft die Applikation auf einem Smartphone.
Um die Immersion zu erhöhen wird das Smartphone in die VR-Brille eingeschoben.
In diesem Fall dient das Telefon sowohl als Anzeigegerät als auch als Sensordatenprovider.
Die VR-Brille besteht ausschließlich aus Linsen welche die Immersion der am Handy laufenden Applikation erhöht.

\subsubsection{Tracking}
\label{sec:tracking}

Unter Tracking versteht man das ermitteln der Position von Objekten in der realen Welt.
Folgend werden Arten das Tracking beschrieben.
Diese beinhalten:

\begin{itemize}
    \item Outside In Tracking
    \item Markerless Inside Out Tracking
    \item Marker Based Inside Out Tracking
\end{itemize}

Wie im vorigen Abschnitt wird hier nur ein Überblick über diese Arten des Trackings gegeben.
Für nähere Informationen wird auf~\cite{Dennis_Ziesecke_2019} verwiesen.

\emph{Outside In Tracking} beschreibt das Ermitteln der Positionen durch außenstehende Sensoren.
Das bedeutet, dass das zu trackende Objekt nicht weiß wo es sich im Raum befindet (Es ist passiv).
Währenddessen ermitteln außenstehende Sensoren die Position der zu trackenden Objekte und gibt diese an die VR-Applikation weiter.

Im Gegensatz dazu gibt es das \emph{Inside Out Tracking}.
Hier ermitteln Sensoren, welche sich auf den Objekten befinden die Position derselbigen.
Dabei gibt es zwei verschiedene Arten, welche bereits oben aufgelistet worden sind.

Im Fall von \emph{Markerless Inside Out Tracking} wird natürliches Licht verwendet.
Typischerweise werden hierbei Kameras verwendet.
Die dabei aufgenommenen Bilder werden mithilfe von Bildverarbeitungsmethoden analysiert und somit wird die Position der Objekte ermittelt.

Bei \emph{Marker Based Inside Out Tracking} wird im Gegensatz kein natürliches Licht verwendet.
Hierbei ist sind die zu trackenden Objekte von Lighthouses (siehe Abschnitt~\ref{sec:lighthouse_tracking}) abhängig.
Diese beleuchten den Raum mit nicht sichtbaren licht welches von Fotosensoren an den Geräten empfangen wird.

\subsection{VR Headset}
\label{sec:vr-headset}
\setauthor{Quirin Ecker}

Es sind einige VR Headsets auf dem Markt.
Nach einer Statistik aus 2017 sind die beliebtesten VR Headset Hersteller Sony, Oculus und HTC (Siehe Abb.~\ref{fig:vr_headset_manufacturer_marketshare}).
Folgend sind 3 VR Brillen beschrieben.
Hierbei wurden die auf die Spielkonsolen-basierten VR Headsets nciht berücksichtigt.

\begin{figure}
    \centering
    \includegraphics[scale=0.25]{pics/vr_headset_manufacturer_marketshare}
    \caption{Market-share VR Headset Hersteller~\cite{MARTINDALE_2017}}
    \label{fig:vr_headset_manufacturer_marketshare}
\end{figure}

\subsubsection{HTC Vive Pro}\label{sec:htc-vive}

Wie bereits in Abschnitt~\ref{sec:vr-headset-types} beschrieben, gibt es von diesen Headsets verschiedene Modelle.
Die HTC Vive Pro ist vom Typ ein tethered Headset mit dem Zusatz, dass auch sogenannte Light Houses gebraucht werden (siehe Abschnitt~\ref{sec:lighthouse_tracking}).
Andere Produkte, wie die im Folgendem beschriebene Oculus Quest benötigen solche nicht~\cite{MECHATECH}.

\paragraph{Vorteile}

\begin{itemize}
    \item \textbf{SteamVR Verwaltung:} die HTC kann mit SteamVR verwaltet werden, womit der manuelle Download von externer Software vermieden wird.
    Für Details über Steam VR wird auf Abschnitt~\ref{subsec:steam} referenziert.
    \item \textbf{Lighthouse Tracking:} Zum Zeitpunkt des Verfassens dieser Arbeit ist Lighthouse Tracking verglichen mit anderen Tracking-Methoden die genaueste.
    Aus Abbildung~\ref{fig:tracking_precision_statistic} kann entnommen werden, dass das Valve Lighthouse Tracking die kleinsten Abweichungen in allen drei Dimensionen hat.
    Ein weiterer Vorteil des Lighthouse Tracking ist, dass kein natürliches Licht für den Tracking Process gebraucht wird~\cite{Dennis_Ziesecke_2019}.
    Details zum Thema Lighthouse Tracking können im Abschnitt ~\ref{sec:lighthouse_tracking} entnommen werden.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{pics/tracking_precision_statistic}
    \caption{Tracking Genauigkeit der VR Headsets~\cite{Macedo_2020}}
    \label{fig:tracking_precision_statistic}
\end{figure}

\paragraph{Nachteile}

\begin{itemize}
    \item \textbf{Komplizierterer Aufbau:} Durch die Notwendigkeit der Base Stations, welche für das Lighthouse Tracking gebraucht werden, ist der Aufbau komplizierter.
    Die Base Stations müssen etwas erhöht sein, weshalb ein Stativ oder sogar eine Wandmontage notwendig ist.
    Außerdem müssen die Base Stations die zu trackenden Geräte im Sichtfeld haben.
    Für weitere Informationen wird auf den Abschnitt~\ref{sec:lighthouse_tracking} verwiesen.
    \item \textbf{Hoher Preis:} Nach der Erhebung, welche in Abb.~\ref{fig:vr_headset_prices} zu sehen ist, befindet sich die HTC Vive Pro im oberen Preissegment.
    \item \textbf{Tethered:} Wie bereits in Abschnitt~\ref{sec:basics} beschrieben worden ist, benötigen tethered Headsets eine permanente Verbindung zu einem Computer.
    Das bedeutet einerseits, dass der Transport komplizierter ist und für Normalverbraucher, ohne einen leistungsstarken Computer, der Preis für das Gesamtsystem steigt.
    Besonders der Transportaspekt ist für diese Arbeit kritisch, da diese an vielen Plätzen hergezeigt werden soll.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{pics/vr_headset_price_statistic}
    \caption{VR Headset Preise~\cite{ALSOP_2019}}
    \label{fig:vr_headset_prices}
\end{figure}

\subsubsection{Valve Index}

Die Valve Index ist eine VR-Brille welche von Valve entwickelt worden ist.
Diese befindet sich genauso wie die HTC Vive Pro~\ref{sec:htc-vive} im teureren Spektrum~\cite{ALSOP_2019} der VR-Brillen und ist dem Typ tethered Headset~\ref{sec:vr-headset-types} zuzuordnen.

\paragraph{Vorteile}

\begin{itemize}
    \item \textbf{Hand Tracking}: Valve benützt bei ihren Controllern einen speziellen Entwurf.
    Die Controller besitzen eine Lasche, welche an dem Griff des Controllers hängt.
    Diese Lasche hält den Controller and der Hand, auch wenn diese den Controller nicht festhält.
    Mit dieser Technik kann der Controller losgelassen werden und die Finger frei bewegt werden.
    Um diese Finger auch in die virtuelle Welt zu übertragen, benützen die Controller Sensoren, welche an diesen angebracht sind.
    Die Informationen der Fingerpositionen können daraufhin von Entwicklern in ihren Spielen benutzt werden.~\cite{SadlyItsBradley_2019}.
    Werden diese nicht benutzt, steht trotzdem noch die normale Controller Steuerung zur Verfügung.
    \item \textbf{Lighthouse Tracking}: Die Valve Index benützt genauso wie die HTC Vive Pro das Lighthouse tracking mit dem Unterschied, dass beide Versionen des Lighthouse Tracking verwendet werden können.
    Für mehr Informationen wird auf~\ref{sec:lighthouse_tracking} verwiesen.
\end{itemize}

\paragraph{Nachteile}

\begin{itemize}
    \item \textbf{Komplizierter Aufbau:} Genauso wie bei der HTC Vive Pro ist der Aufbau etwas komplizierter, da das Lighthouse Tracking~\ref{sec:lighthouse_tracking} verwendet wird.
    \item \textbf{Hoher Preis:} Noch teurer, wie die zuvor genannte HTC Vive Pro ist die Valve Index.
    Dies ist in der Abb.~\ref{fig:vr_headset_prices} ersichtlich.
    \item \textbf{Tethered:} Wie bereits zuvor beschrieben ist auch die Valve Index ein tethered Headset.
    Somit braucht auch diese eine permanente Verbindung zu einem Computer.
    FÜr mehr Informationen wird auf Abschnitt~\ref{sec:vr-headset-types}
\end{itemize}

\subsubsection{Oculus Quest 2}\label{sec:oculus-quest-2}

Die Oculus Quest 2 ist eine VR-Brille welche von Facebook/Meta im Jahre 2020 entwickelt worden is~\cite{ADI_ROBERTSON_2020}.
Diese Brille ist eine Mischung von einem tethered Headset und einem Standalone Headset~\ref{sec:vr-headset-types}.
Dies bedeutet, dass die Oculus Quest 2 ohne einen Computer benutzbar ist, aber auch mit einem USB-C Kabel zu einem Computer verbunden werden kann.
Ist das Headset mit dem Computer verbunden können PC exclusive Spiele mit der Oculus Quest 2 auch gespielt werden~\cite{ADI_ROBERTSON_2020}
Für den Aufbau werden nur das Headset und zwei Controller benötigt.

\paragraph{Vorteile}

\begin{itemize}
    \item \textbf{Einfacher Aufbau:} Im Gegensatz zu den zuvor genannten VR-Brillen benötigt die Oculus Quest 2 kein Lighthouse Tracking verwendet.
    Dies hat einen einfacheren Aufbau zur Folge, da keine Basistationen aufgebaut werden müssen.
    Zum Aufbau werden lediglich die Brille, die Controller und eventuell noch ein Computer verwendet, wenn die Oculus Quest im tethered Modus gebraucht wird~\cite{MECHATECH}.
    \item \textbf{Günstiger Preis:} Die Oculus Quest ist im Vergleich zu den zuvor genannten Brillen eine günstigere Alternative.
    Dennoch gibt es noch günstigere VR-Headsets auf dem Markt.
    Für nähere Einsicht wird auf die Abb.~\ref{fig:vr_headset_prices} verwiesen.
    \item \textbf{Standalone:} Wie bereits beschrieben ist die Oculus Quest 2 eine Mischung aus tethered und standalone Headset.
    Kein Computer wird benötigt unter der Voraussetzung, dass auf die Leistung des Computers verzichtet werden kann.
    Für mehr Information wird auf Abschnitt~\ref{sec:vr-headset-types} verwiesen.
\end{itemize}

\paragraph{Nachteile}

\begin{itemize}
    \item \textbf{Lichtabhängigkeit:} Durch das kamera-basierte Tracking-system~\ref{sec:oculus_quest_tracking} ist die Oculus Quest 2 von dem natürlichen Licht abhängig~\cite{Dennis_Ziesecke_2019}.
    Dieses Problem wurde von den zuvor genannten VR-Brillen durch das Licht der Basistationen gelöst~\ref{sec:lighthouse_tracking}\cite{Dennis_Ziesecke_2019}.
    \item \textbf{Full Body Tracking:} Die HTC Vive Tracker, welche üblicherweise für das Full Body Tracking verwendet werden, funktionieren mit dem Lighthouse Tracking~\ref{sec:lighthouse_tracking}.
    Da die Oculus Quest 2 diese Trackingmethode nicht verwendet kann das Full-Body-Tracking etwas komplizierter werden.
    Für verschiedene Möglichkeiten Full Body Tracking trotzdem zu erreichen wird auf~\cite{Martin_Rakver} verwiesen.
    \item \textbf{Tracking:} In Abb.~\ref{fig:tracking_precision_statistic} ist ersichtlich, dass das Tracking der Oculus Quest 2 schlechter abschneidet wie das der zuvor genannten Brillen.
\end{itemize}

\subsection{Tracker}\label{sec:tracker}

\subsubsection{Vive Tracker}\label{sec:vive-tracker}

\subsection{Lighthouse Tracking}\label{sec:lighthouse_tracking}

\subsubsection{Grundlagen}

Die HTC Vive Brillen und die Valve Index benützen beide das Lighthouse-Tracking~\cite{steam_lighhouse_versions}.
Diese Form des Trackings ist genauso wie das Tracking der Oculus Quest und Oculus Quest 2 (siehe~\ref{sec:oculus_quest_tracking, sec:oculus-quest-2}) ein Inside-Out Tracking.
Im Gegensatz zu der Oculus Quest benützt das Lighhouse Tracking kein natürliches Licht, sondern für das Auge unsichtbares Licht.
Diese Form des Tracking wird auch Marker-Based Inside-Out Tracking genannt\ref{sec:tracking}.
Im Falle des Lighhouse Tracking beleuchten die Base Stations die zu trackenden Geräte, womit sich die Geräte orientieren können.
Dies hat den Vorteil, dass die Benutzung der Vr Brille nicht von dem natürlichen abhängig ist.
Statt Kameras besitzt ein zu trackendes Gerät Fotosensoren~\cite{Buckley_2015}.

\subsubsection{Positionierung}

Damit dieser Vorgang fehlerfrei funktioniert werden typischerweise zwei Basestations verwendet
Diese werde wie in Abb~\ref{fig:basetstation_positioning} positioniert.
Mögliche Fehler können auftreten, wenn die Lighthouses keine klare Sicht auf die Geräte haben~\cite{steam_lighhouse_versions}..

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{pics/basestations_positioning}
    \caption{Positionierung der Lighhouses~\cite{Sercan_2018}}
    \label{fig:basetstation_positioning}
\end{figure}

\subsubsection{Funktionsweise}

Die Base Station besteht aus Syncblinker und Laseremitter.
Der Syncblinker ist ein Infrarot Strahl und die anderen 2 Laseremitter sind Lichtstrahlen welche sich 60-mal in der Sekunde auf einer Drehscheibe drehen.
Um die Position zu ermitteln, flasht der Sync Blinker und sobald dieser bei der Brille ankommt, fängt das Gerät zu zählen an bis die Lichtstrahlen der Laseremitter ankommen.
Durch die Drehscheibe, auf der sich die Laseremitter befinden, beleuchtet die Base Station so viele wie mögliche Sensoren.
Die Position mehrerer Punkte des Gerätes ist somit bekannt und es kann die Rotation der Brille ebenfalls berechntet werden~\cite{Buckley_2015, Skarredghost_2017}.

\subsubsection{Versionen}

Zum Zeitpunkt das Verfassen der Diplomarbeit gibt es 2 Versionen der Base Stations.
Version 1.0 und 2.0 sind nicht miteinander kompatibel.
Folgend sind die Versionen aufgelistet mit den jeweils kompatiblen Geräten in der Klammer.
Wobei Steam bei der Kompatibilität nur HTC Brillen und die Valve Index vermerkt haben, weshalb andere Brillen in der folgenden Liste ausgenommen worden sind~\cite{steam_lighhouse_versions}.

\begin{itemize}
    \item Lighthouse 1.0 (HTC Vive, Valve Index)
    \item Lighthouse 2.0 (HTC Vive Pro, Valve Index)
\end{itemize}

\emph{1.0 Lighthouses} besitzen eine nahezu quadratische form mit einer Länge von 15 cm, einer Breite von 16 cm und einer höhe von 10 cm

\emph{2.0 Lighthouses} haben einer eher rechteckige form mit einer Länge von 15 cm, einer Breite von 13,30 cm und einer Höhe von 12,90 cm.
Die Vorderseite ist der Länge nach abgerundet, mit welcher eine höhere Reichweite erreichbar is.
Mit der neuen Version ist es auch möglich mehrere Base Stations zu verwenden.
Durch die erhöhte Sichtweite und der Möglichkeit mehr wie zwei Lighthouses zu verwenden kann eine größere Spielfläche verwendet werden.
Der Sichtkontakt der Lighhouses ist nicht mehr nötig~\cite{Cale_2019}.

\subsection{Oculus Quest Tracking}
\label{sec:oculus_quest_tracking}

Eine weitere Art das Tracking wird benutzt von Oculus.
Wie bereits in~\ref{sec:lighthouse_tracking} erwähnt benutzt die Oculus Quest und Oculus Quest 2 ein Inside Out Tracking.
Die Oculus Quest benützt Kameras, um sich im VR Raum zu orientieren.

\subsubsection{DoF}

Es gibt zwei verschiedene Arten des Oculus Quest und Oculus Quest 2 Tracking zwischen denen das Headset wechseln kann.
Diese arten gelten nur für das VR Headset und nicht die Controller~\cite{oculus_support_headset_tracking}.

\begin{itemize}
    \item 3DoF
    \item 6Dof
\end{itemize}

\emph{3DoF} bedeutet, dass die Rotation des VR Headsets getracked werden.
Die Position wird nicht getracked.
Oculus empfehlt nur im Sitzen oder im Stehen zu spielen, wenn 3DoF aktiviert ist.

Bei \emph{6DoF} wird auch die Position getracked.
Viele Spiele setzen vorraus, dass die Position getracked wird.

\subsubsection{Headset Tracking}

Das Oculus Quest 2 Headset benützt ein etwas anderes Tracking.
Durch die Kameras, welche in dem Headset verbaut, sind analysiert es die Umgebung.
Mit Bildverarbeitung erstellt es es aus den aufgenommenen Bildern eine 3d Map.
Diese 3d Map wird benutzt um das Headset im dreidimensionalen Raum zu positionieren und rotieren~\cite{MECHATECH}.

\subsubsection{Controller Tracking}

Oculus nennt ihre virtual reality controller oculus touch.
Diese haben einen ring welcher einen Ring um die Hand Bilden, auf welchen sich eine Infrarot LED befindet.
Die Infrarot LED ist so positioniert, damit sie in die Richtung des Headsets schauen.
Parallel machen die Kameras, welche auf dem Headset sich befinden, Fotos.
Durch die Infrarot LED Strahlen kann das Headset mit den Fotos die Position der Controller ermitteln.
Das Infrarotlicht der Controller ist für das menschliche Aug nicht sichtbar~\cite{Gajsek_2022}.
Im Gegensatz zum Headsets benützen die Controller nach definition ein Outside in Tracking, da die Controller nicht von alleine wissen, wo sie sich im Raum befinden und das tracking mithilfe des Headset funktioniert.

\subsubsection{Guardian}

Oculus Guardian ist ein Sicherheitssystem, bei welchen man eine gewisse Spielfläche definieren kann.
Die Grenzen der Spielfläche werden dann angezeigt, wenn man sich diesen nähert~\cite{Oculus_Guardien}.

\emph{Guardian Space Sense} ist ein weiteres Sicherheitssystem.
Durch die 3d Map, welche schon in dem Abschnitt Headset Tracking beschrieben worden ist, kann auch eine Hilfestelle für den Nutzer geleistet werden.
Hier versuch die Oculus Quest Umrisse von Gegenständen, Menschen und anderen Lebewesen in der virtuellen realität sichtbar zu machen, wenn sich der Nutzer diesen nähert~\cite{Oculus_Guardien}.

\subsection{Wireless Virtual Reality}
\label{subsec:wireless-virtual-reality}

VR-Brillen wie die HTC Vive, HTC Vive Pro, Valve Index und zu einem bestimmten Ausmaß auch die Oculus Quest 2 hängen normalerweise and einem Kabel.
Diese Brillen werden auch tethered Headsets genannt und wurden bereits in dieser Arbeit in dem Abschnitt~\ref{sec:vr-headset-types} beschrieben.
Durch die permanente Anbindung an einen Computer kann das Kabel die Mobilität einschränken und die Immersion brechen~\cite{Oculus_2021}.
Aus diesem Grund gibt es einige Lösungen, die dieses Problem lösen wollen.
Folgend werden zwei Lösungen näher Erläutert.
Diese umfassen den Oculus Air Link und Vive WLAN Adapter.

\subsubsection{Vive Wireless Adapter}

Bei dem Vive wireless Adapter wird zusätzliche Hardware zur Brille benötigt.
Diese beinhalten:

\begin{itemize}
    \item Powerbank
    \item Wireless Link Box
    \item PCIe WiGig Card
    \item anderes Zubehör
\end{itemize}

Für Informationen zu der zusätzlichen Hardware wird auf~\cite{ViveWirelessAdapter} verwiesen

Zum Zeitpunkt der Erstellung dieser Arbeit konnten keine zuverlässigen technischen Spezifikationen gefunden werden.
Daher kann die Funktionsweise nur sehr oberflächlich beschrieben werden.

Grundsätzlich wird für die Funktionalität die Wireless Link Box gebraucht, welche mit der PCIe WiGig Card verbunden ist.
Die Wireless Link Box kombiniert mit der Antenne welche sich auf der VR-Brille befindet verschafft HTC ein möglichst latenz freies Erlebnis.
Durch die ständige Bewegung der VR-Brille variiert die Brandweite konstant.
Für dieses Problem benützt der Wireless Adapter einen Algorithmus welcher das Videosignal je nach Bandbreite in echtzeit komprimiert~\cite{VRConduit_2018}.

Durch die zusätzliche Hardware ist die HTC Lösung etwas teuer.
Eine Lösung ohne zusätzliche Kosten wurde von Oculus entwickelt und wird Oculus Air Link genannt.

\subsubsection{Oculus Air Link}

Auch, wenn die Oculus Quest 2 und Oculus Quest bereits wireless Headsets sind kann man diese wie bereits zuvor beschrieben mit dem Computer verbinden.
Diese Verbindung wird Oculus Link genannt und besteht aus einem qualitativ hochwertigen USB C 3.0 Kabel~\cite{William_2020}.

Um die Leistung eines PCs nun in Anspruch zu nehmen, ohne das Kabellose Erlebnis aufzugeben, entwickelte Oculus Quest Oculus Air Link~\cite{Oculus_2021}.
Oculus Air Link wurde mit der Version 28 zu der Oculus Quest 2 hinzugefügt, welche am 19\. April 2021 herausgekommen ist~\cite{Oculus_2021, oculus_patchnotes}.

Der Oculus Air Link braucht im Gegensatz zu dem zuvor genannten Vive Wireless Adapter keine weitere Hardware um zu funktionieren.
Um diesen zum Laufen zu bekommen wird nur die Oculus App gebraucht.
Einer der Gründe dafür ist, dass kein zusätzlicher Akku für die Brille notwendig ist, da dieser sowieso schon für das standalone Erlebnis gebraucht wird.
Für mehr Informationen zu dem Aufsetzen des Oculus Air Link wird auf~\cite{Oculus_AirLink} verwiesen.

Ähnlich wie der Vive Wireless Adapter benützt der Oculus Air link auch WLAN für die Datenübertragung~\cite{Oculus_2021}.
Dabei benützt Oculus die gleiche Streaming-Pipeline welche auch bei Oculus Link verwendet worden ist~\cite{Oculus_2021}.

\section{Software}

\subsection{Game Engine}

Es gibt mehrere Games Engines mit welchen eine VR Applikation entwickelt werden kann.
In Abb.~\ref{fig:game_engine_marketshare} ist der Marktanteil verschiedener Engines abgebildet.
Diese Daten sind aber mit Vorsicht zu genießen, da das Skript welche diese Daten geliefert hat nach einigen Kriterien handelt,(siehe~\cite{REDDIT_2018}).
Dies bedeutet beispielsweise, dass nur Spiele mit einer Wikipedia Seite mit einberechnet werden.

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{pics/game_engine_marketshare}
    \caption{Game Engine Market-share~\cite{REDDIT_2018}}
    \label{fig:game_engine_marketshare}
\end{figure}

\begin{figure}
    \includegraphics[scale=0.4]{pics/programming_languages_hardest}
    \caption{Schwerste Programmiersprachen~\cite{JAXCENTER_2018}}
    \label{fig:hardest_programming_languages}
\end{figure}

\subsubsection{Unity}

Unity ist eine Game Engine, welche von Unity Technologies initial exklusiv für Apple Mac OS X entwickelt wurde.
Die Engine wurde portiert und kann heute auch auf Windows und auf der Linux Plattform benützt werden.
Sie ist für alle im prinzip gratis bis zu einem bestimmten Umsatz.
Auch wenn sie eine Einsteiger Engine genannt wird, ist sie trotzdem im professionellen Bereich in benutzung und viele bekannte Spiele, wie Pokemon GO, Among us und Hearthstone wurden in der Unity Engine entwickelt~\cite{Haas2014AHO,Unity_System_Specification,UNITY_PRICING_1,WIKIPEDIA_UNITY_GAME_LIST_2014}.

\paragraph{Vorteile}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{pics/mobile_os_marketshare}
    \caption{Mobile Betriebssystem Market Share~\cite{StatCounter_Mobile_2021}}
    \label{fig:mobile-os-market-share}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{pics/desktop_os_market_share}
    \caption{Desktop Betriebsystem Market Share~\cite{StatCounter_Desktop_2021}}
    \label{fig:desktop-os-market-share}
\end{figure}



\begin{itemize}
    \item \textbf{Leichter Einstieg:} Das Einsteigen in Unity ist ein sehr einfacher Prozess.
    Die einzige Voraussetzung für den Start einer Unity Applikation ist ein Unity Account.
    Nach der Erstellung eines Accounts kann das Unity Hub heruntergeladen werden.
    Anschließend kann in dem Unity Hub eine Version der Unity Engine heruntergeladen werden~\cite{Unity_Download}.
    Anfangs ist die Engine gratis, fallen nach einem bestimmten Umsatz an~\cite{Unity_Pricing_2}.
    \item \textbf{Programmiersprache:} In Abb.~\ref{fig:hardest_programming_languages} ist ersichtlich, dass viele Programmierer der Meinung sind, C\# einer der einfacheren zu lernenden Sprachen ist.
    Verglichen mit den C++, welches die Programmiersprache der Unreal Engine ist, hat sie nach der Abb. eine weitaus kleinere Lernkurve.
    \item \textbf{Plattform Kompatibilität:} Applikationen, welche in Unity entwickelt worden sind haben eine hohe Plattformunabhängigkeit.
    Unity Applikationen können für die größten Desktop- und Mobile Betriebssysteme gebaut werden.
    Siehe dazu Abb.~\ref{fig:desktop-os-market-share} und Abb.~\ref{fig:mobile-os-market-share}.
    Für eine volle Liste der unterstützten Plattformen wird auf~\cite{UNITY_PLATTFORMS} verwiesen.
\end{itemize}

\paragraph{Nachteile}

\begin{itemize}
    \item \textbf{Market Share:} Nach Abb.~\ref{fig:game_engine_marketshare} hat die Unity Engine weniger Market-share wie beispielsweise die Unreal Engine.
    \item \textbf{Kostenanfall:} Es ist in~\cite{UNREAL_ENGINE_PRICING_2022} und~\cite{Unity_Pricing_2} ersichtlich, dass bei Unity schneller Kosten anfallen wie bei der Unereal Engine.
    Das bedeutet nicht, dass die Kosten bei Unity mehr sind wie bei Unreal Engine, sondern, dass die kostenlose Entwicklungsphase bei Unreal länger ist.
\end{itemize}

\subsubsection{Unreal Engine}
\label{sec:unreal_engine}

Unreal Engine wird von Epic Games entwickelt~\cite{UNEAL_ENGINE_OWNER_2022}.
Diese Engine ist eine weit verbreitete Game Engine.
Dies kann man Abbildung~\ref{fig:game_engine_marketshare} entnehmen.
Viele Spiele wie Fortnite, Ark Survival Evolved, Borderlands 3 und Jedi Fallen Order sind mit dieser Engine entwickelt worden~\cite{WIKIPEDIA_UNREAL_GAME_LIST}.

\begin{figure}
    \centering
    \includegraphics[scale=0.3]{pics/visual_scripting_unreal_engine}
    \caption{Visual Scripting in Unreal Engine 5}
    \label{fig:visual_scripting_unreal_engine}
\end{figure}

\paragraph{Vorteile}

\begin{itemize}
    \item \textbf{Market Share:} In Abb.~\ref{fig:game_engine_marketshare} ist ersichtlich, dass Unreal den Größten Market Share.
    Dies ist genauso wie zuvor mit Vorsicht zu genießen, da diese Daten wie bereits beschrieben unter einem bestimmten Kriterium gesammelt worden sind.
    \item \textbf{Visual Scripting:} Unreal Engine benutzt für das Scripting der Applikation neben der Programmiersprache C++ ein visual scripting System, welches auch Blueprint genannt wird.
    Anders wie in Bolt, welches das Visual Scripting Tool für Unity ist, ist das Blueprint System bereits eingebaut.
    Bolt muss noch extra installiert und konfiguriert werden~\cite{Unity_Bolt}.
    Das integrierte Blueprint System hat seine Nachteile und seine Vorteile.
    Ein Vorteil ist die abgeschwächte Lernkurve, die das System gegenüber von C++ bietet um die Unreal Engine kennenzulernen.
    Dies zumindest nach~\cite{Mower_UnrealEngine} und~\cite{jwatte_2017}.
     %TODO: Statistic for visual scripting vs Code
    ~\ref{fig:visual_scripting_unreal_engine}
    \item \textbf{Kostenanfall:} Wie bereits bei den Nachteilen der Unity Engine besprochen fallen die Kosten bei der Unreal Engine langsamer and wie bei der Unity Engine..\cite{UNREAL_ENGINE_PRICING_2022, Unity_Pricing_2}
\end{itemize}

\paragraph{Nachteile}

\begin{itemize}
    \item \textbf{Unterstützte Spielplattformen:} Applikationen, welche mit Unreal Engine gemacht worden sind können für weniger Plattformen entwickelt werden wie bei der Unity Engine~\cite{Viscirele_Unreal_v_Unity}.
    \item \textbf{Unterstützte Entwicklerplattformen:} Mit der Unreal Engine ist es möglich auf den drei größten Desktop Betriebssystemen, welche in Abb.~\ref{fig:desktop-os-market-share} ersichtlich sind, zu entwickeln.
    Dennoch ist es komplizierter die Game Engine auf Linux zu installieren, da man hier die Game Engine selber von der Quelle bauen muss.
    Es gibt keinen offiziellen Binary Installer für Linux~\cite{Unreal_Installationsguide}.
    \item \textbf{C++:} Für erweiterte Funktionalität, welche nicht mit dem Blueprint System implementiert, werden kann, muss auf C++ zurückgegriffen werden.
    In Abb.~\ref{fig:hardest_programming_languages} ist zu sehen, dass C++ eine starke Lernkurve hat.
\end{itemize}

\subsubsection{Source Engine und Source 2 Engine}

Es gibt mittlerweile 2 Iterationen dieser Engine.
Zum einen die originale Source Engine und die Source Engine 2.
Die Markteinführung der ursprünglichen Source Engine war im Juni 2004~\cite{Bryan_Wirtz_SOURCE_ENGINE_2022}.
Daraufhin ist die Source 2 Engine im August 2014 erschienen~\cite{VALVE_DEVELOPER_COMMUNITY_SOURCE2}.
Beide Engines sind von Valve entwickelt worden~\cite{VALVE_DEVELOPER_COMMUNITY_SOURCE, VALVE_DEVELOPER_COMMUNITY_SOURCE2}.
Verantwortlich ist die Source 2 Engine für Spiele wie Dota 2 und Half Life Alyx~\cite{WIKIPEDIA_SOURCE2_ENGINE_GAME_LIST}.
Andere Spiele wie Half Life 2, Counterstrike Source, Portal, Portal 2 und Counterstrike Global Offensive sind mit der originalen Source Engine entwickelt worden~\cite{WIKIPEDIA_SOURCE_ENGINE_GAME_LIST}.
Auch als VR Entwicklungsumgebung eignet sich die Source 2 Engine, da sie für Half Life: Alyx, eines der erfolgreichsten VR Spiele benutzt worden ist~\cite{WIKIPEDIA_SOURCE2_ENGINE_GAME_LIST, Aden_Carter_2020}.
Die folgenden Vorteile und Nachteile beziehen sich auf die Source 2 Engine.

\paragraph{Vorteile}

\begin{itemize}
    \item \textbf{Gratis:} Die Source Egnine ist grundsätzlich komplett Gratis.
    Es gibt keine Kostenanfälle durch das nutzen der Engine.
    Das einzige Kriterium von Valve ist, dass die Engine auf Steam publiziert werden muss~\cite{Brenna_Hillier_2015}.
\end{itemize}


\paragraph{Nachteile}\label{pgr:cons}

\begin{itemize}
    \item \textbf{Market Share:} In Abb.~\ref{fig:game_engine_marketshare} ist ersichtlich, dass die Source Engine verglichen mit den zuvor gennanten Game Engines keinen großen Marktanteil hat.
    Weniger Nutzung einer Engine bedeutet auch weniger unterstützung, welche es online zur Verfügung gibt.
    \item \textbf{Publizierung:} Wie bereits bei den Vorteilen angesprochen, muss ein Spiel, welches mit der Source Engine entwickelt worden ist auch auf Steam publiziert werden~\cite{Brenna_Hillier_2015}.

\subsection{Steam}\label{subsec:steam}

\subsection{VR in Unity}
\setauthor{Florian Beckerle}
Unity bietet bereits eine eingebaute basis VR API, welche ein paar Features für die Verwendung von VR Geräten zur Verfügung stellt.
Diese muss jedoch erst Eingstellt werden, das geht in folgenden Schritten.

Um Vr für die Spiele zu aktivieren, müssen zuerst den Player Settings, welche im Menu bei Edit > Project Settings > Player zu finden sind, geöffnet werden.
Als nächstes muss die Option Virtual Reality Supported aktiviert werden, dass in der Box ein Häcken zu erkennen ist, siehe Abb. ~\ref{fig:unity_vr_api_settings}.
In der darunter stehenden Liste, namens Virtual Reality SDKs, können nun mit dem Plus-Knopf eine neue SDK hinzugefügt werden.
Ein Beispiel hierfür wäre die Oculus SDK.
Der Minus-Knopf bietet die Möglichkeit diese SDKs wieder zu entfernen, siehe Abb. ~\ref{fig:unity_vr_api_settings}.
~\cite{Unity_VR_Overview_2022}

Wenn VR aktiviert wurde, wird das Spiel automatisch auf die VR-Brille gerendert und dort angezeigt.
Weiters besitzt jede Kamera, welche im Spiel ist, eine Option, auf welches Auge das Ausgangsignal angezeigt werden soll, zum Beispiel linkes-, rechtes-, beide- oder keine Augen.
Unter den Augen versteht man die Bildschirme der VR-Brille welche sich vor den Augen des Benutzers befinden.
Ein weiteres automatisches Feature ist, dass die Bewegung der VR-Brille in der realtität auf die Position der Kamera im Spiel übertragen wird.

Unity empfielt für die verwendung der Api folgende Brillen, Gear VR, Oculus CV1 und die Vive.
~\cite{Unity_VR_Overview_2022}

\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/unity_basis_vr_api_settings}
    \caption{Unity VR API - Settings}
    \label{fig:unity_vr_api_settings}
\end {figure}

\subsection{VR Plugin}
\setauthor{Florian Beckerle}
Für BeamVR wurde das SteamVR Unity Plugin verwendet.
Es wurde von Valve entwickelt und bietet bereits eine Vielzahl an vorgefertigten Demos, welche mit der Installation des Plugins mitgeliefert werden, diese werden später genauer beschrieben..
~\cite{SteamVR_Overview_2022}

\subsubsection{Quickstart}
\setauthor{Florian Beckerle}
Für das Setup des SteamVR Unity Plugins sind 5 Schritte notwendig.
Damit alles Funktioniert muss SteamVR von Steam und das Plugin vom Unity Asset Store gedownloaded werden.
Nachdem die Installation beider Softwares abgeschlossen wurde, muss das Plugin, über den Package Manager, in das Unity Projekt importiert werden.
Im Menu Window wird nun eine neue Option namens SteamVR Input angezeigt, siehe Abb. ~\ref{fig:steamvr_input_menu_item}.
\begin {figure}
    \centering
    \includegraphics[scale=0.9]{pics/steamVR_Input_MenuItem}
    \caption{Steam VR - Input Menu Item}
    \label{fig:steamvr_input_menu_item}
\end {figure}
Wenn man auf diese klickt erscheint ein Popup welches fragt ob JSON Files kopiert werden sollen, dort drückt man auf Ja, siehe Abb. ~\ref{fig:steamvr_copy_json}.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_Input_CopyJSON}
    \caption{Steam VR - Copy JSON}
    \label{fig:steamvr_copy_json}
\end {figure}
Nachdem der Vorgang abschlossen ist, öffnet sich das SteamVR Input Fenster, dort muss nun Save and Generate gedrückt werden, siehe Abb. ~\ref{fig:steamvr_save_and_generate}.
\begin {figure}
    \centering
    \includegraphics[scale=0.6]{pics/steamVR-Input-SaveAndGenerate}
    \caption{Steam VR - Save and Generate}
    \label{fig:steamvr_save_and_generate}
\end {figure}
Nun ist die Installation abgeschlossen und das SteamVR Unity Plugin ist einsatzbereit.
~\cite{SteamVR_Quickstart_2022}

\subsubsection{Render Models}
\setauthor{Florian Beckerle}
Das SteamVR Unity Plugin bietet eine virtuelle Darstellung der Kontroller, welche der Benutzer in den Händen hält.
Die gezeigten Modelle benötigen hierfür mehrere Attribute, siehe Abb. ~\ref{fig:steamvr_render_models Script}.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_render_models_script}
    \caption{Steam VR - Render Models Script}
    \label{fig:steamvr_render_models Script}
\end {figure}
Der Index ist der Index des getrackten Gerätes, und wird vom System wie eine ID zur Erkennung verwendet.
Mittels dem Model Override kann man für Testzwecke ein bestimmtes Modell festlegen welches angezeigt werden soll.
Die Shader können die Darstellung des Objektes verändern.
Verbose gibt die Vorgänge im Script in der Konsole aus, diese Option wird jedoch nur für das Testen benötigt.
Create Components erstellt individuelle Objekte für jeden Komponenten welcher verfügbar ist.
Update Dynamically bewegt die einzelnen Komponenten gleich wie die physischen Gegenstücke.
~\cite{SteamVR_Render_Models_2022}

\subsubsection{Input}
\setauthor{Florian Beckerle}
Die die Hardware für VR Geräte schnell weiterentwickelt wird, hat Valve auf ein KeyBinding System zurückgegriffen.
Die Entwickler und die Benutzer selbst können für neue oder breits vorhandene Hardware einstellen, welche Funktion die einzelnen Knöpfe und Trigger haben.
Diese Aktionen wurden in 6 verschiedene Input Typen und einen Output Typen  aufgeteilt.

Die Aktion Boolean besitzt zwei Zustände, true und false.
Sie wird oft benutzt um Objekte zu greifen, da man zum Beispiel einen Würfel entweder aufheben können soll oder nicht.

Single Aktionen können analoge Werte zwischen 0 und 1 annehmen und wird für Situationen benutzt wo der Boolean nicht ausreicht.
Ein Anwendungsfall ist ein Auto, welches bei 0 stehen bleibt und bei 1 Vollgas fährt.
Als Eingabe kann zum Beispiel der Trigger des Kontrollers benutzt werden.

Vector2 besitzt zwei Werte, X und Y.
Die Bewegungen des Kontrollers werden hierbei nur auf zwei Achsen gemessen.

Vector3 besitzt im Gegensatz zu Vector2 drei verschiedenen Werte X, Y und Z.
Diese Aktion wird selten benutzt, findet aber zum Beispiel im SteamVR Home einen Anwendungsfall beim Scrollen.

Pose gibt die Position und Rotation in einem dreidimensionalen Raum wieder.
Es wird dazu benutzt um die Bewegungen der Controller zu messen und digital nachzubilden.

Skeleton benutzt das SteamVR Skeleton Input um die ungefähre Position und Rotation der Finger zu erkennen, während der Kontroller in den Händen gehalten wird.

Vibration werden für haptisches Feedback bei VR Geräten verwendet.
Hierbei vibrieren der Kontroller, eine spezielle Haptik Weste oder ein preparierter Sessel.
~\cite{SteamVR_Input_2022}

\subsubsection{Skeleton Input}
\setauthor{Florian Beckerle}
Das Plugin bietet die Möglichkeit Hände mit Fingern und deren aktuellen Position darzustellen.
Die Bewegungen werden hierbei zwischen zwei verschiedenen Begränzungen der Fingerpositionen unterschieden.
WithContoller berechnet eine ungefähre Position der Finger während diese einen Kontroller in den Händen halten.
Dies dient besonders dazu, die Interaktion zwischen der realen Hand und dem realen Kontroller digital darzustellen.
WithoutController bietet die Bewegungen von Fingern, wenn sie keinen Kontroller in der Hand halten.
In der realtität kann währenddessen jedoch trotzdem ein Kontroller gehalten werden, es wird nur digital nicht angezeit, siehe Abb. ~\ref{fig:steamvr_skeletal_input_models}.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_skeletal_input_models}
    \caption{Steam VR - Skeletal Input Models}
    \label{fig:steamvr_skeletal_input_models}
\end {figure}
Die Positionen der Finger werden Relativ zu dem in der Hirarchie übergestuften Objekt und dem Model gemessen.
Jeder Finger besteht hierbei standardmäßig aus 4 Gelenken.
Ein Wert im Bereich von 0 bis 1 gibt an wie stark die Finger eingerollt sein sollen.
Die Finger einer Hand sind bei SteamVR etwas auseinander gestpeizt, hier wird ebenfalls ein Wert von 0 bis 1 dazu verwendet um die distanz zwischen den Fingern zu verändern.

Um die Position der Finger zu messen gibt es grunsätzlich drei verschiedene Methoden.
Bei Estimated kann die Position des Körperteiles nicht direkt bestimmt werden.
Jede Bewegung wird nur über die Bediehung der Trigger, Knöpfe und Trackpads des Kontrollers gestimmt.
Partial kann die bewegungen der Finger direkt bestimmen, jedoch nur eingeschränkter als wie die tatsächlichen Finger.
Die Positionen werden durch andere Werte, wie zum Beispiel von speziellen Handschuhen, gemessen.
Full kann die komplette Körperbewegung des Benutzers messen, wie zum Beispiel durch Motion Caputre Anzügen oder handschuhen.

Das Script, welches für die Bewegung des Modelles zuständig ist, besitzt eine Vielzahl an verschiedenen Optionen, siehe Abb. ~\ref{fig:steamvr_skeletal_input_Script}.
Update Pose setzt die Position und Orientierung des Objektes neu, sobald der Controller bewegt wurde.
Mirroring gibt an, ob die Knochen Daten entlang der X-Achse gespiegelt werden sollen.
Die Blend Optionen bieten Einstellungsmöglichkeiten den Übergang zwischen Verschiednen Bewegungsmöglichkeiten und Animationen zu verändern.
Weiters kann man einen bestimmten Knochen mittels GetBonePosition bekommen und die Positionen und Rotationen werden bittels GetBonePositions und GetBoneRotations bereitgestellt.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_skeletal_input_script}
    \caption{Steam VR - Skeletal Input Script}
    \label{fig:steamvr_skeletal_input_Script}
\end {figure}
~\cite{SteamVR_Skeleton_Input_2022}

\subsubsection{Interaction System}
\setauthor{Florian Beckerle}
Das Interaction System funktioniert mittels dem Senden von Nachrichten an Objekte, mit welchen die Hände des Spielers oder andere Objekte interagieren.
Diese Objekte können sich an die Hand anheften und somit gehalten werden.
Das System bietet die Möglichkeit Maus Events nachzuahmen, somit funktioniert die interaktion mit der Benutzeroberfläche auch in VR.

Die Player Klasse weiß wo die VR-Brille und die Kontroller positioniert sind.
Mittels den Methoden hmdTransform und feetPositionGuess können die Positionen der Brille und eine schätzung der Fußstellung zurückgeliefert werden.

Die Hand Klasse wird für die meißten Funktionen des Interaction Systems benötigt.
Sie sendet interagierbaren Objekten Nachrichten über den aktuellen Status der Hand.
Sie kann nur mit einem Objekt gleichzeitig direkt Interargieren, darunter versteht man das aufheben und werfen dieser.
Objekte können an die Hand angebracht und wieder losgelöst werden.
Das Verhalten der Hände kann durch sogenannte AttachmentFlags veränder werden, welche bei einer Interaktion aktiviert werden.

Interactable Objekte können von Spielern aufgehoben werden, solange ein bestimmter Knopf gedrückt wird.
Befindet sich die Hand, während dieser Knopf losgelassen wird, in Bewegung wird die Geschwindigkeit und die Richtung auf das Objekt übertragen und es wird geworfen.
%%Optional noch andere Scripts erklären falls notwendig, erscheinen jedoch nicht sonderlich wichtig (wichtigere noch mit !)
%    Throwable
%    LinearDrive
%    CircularDrive
%    LinearMapping
%    VelocityEstimator !!
%    IgnoreHovering
%    UIElement
%    ItemPackage
%    ItemPackageSpawner
%    ItemPackageReference
%    PlaySound
%    SoundPlayOneShot
%    Util
%    InteractableHoverEvents
%    InteractableButtonEvents
%    ComplexThrowable
%    DistanceHaptics
%    Player (Prefab) !!
%    BlankController (Prefab)
%    Teleport !!
%    Render Model
%    Hints
%    Samples
~\cite{SteamVR_Interaction_System_2022}

\subsubsection{Skeleton Poser}
\setauthor{Florian Beckerle}
Der Skeleton Poser funktioniert mithilfe von verschienen Posen, welche erstellt und eingefügt werden können.
Mittels dem Blending Editor des Posers kann zwischen verschiedenen Posen ein Übergang erstellt werden.

Hierbei existieren 4 Modi für die Fingerbewegungen.
Der Static Modus erlaubt keine Fingerbewegungen und beachtet nur die Posen.
Bei Free können die Finger frei bewegt werden und die Pose wird ignoriert.
Mittels Extend können die Finger komplett ausgestreckt werden, aber nur nicht weiter eingerollt werden, als es bei der Pose eingestellt wurde.
Bei Contract können die Finger ganz eingerollt werden, jedoch nicht weiter Ausgestreckt werden als bei der Pose.
~\cite{SteamVR_Skeleton_Poser_2022}

OpenVR Plugin
\subsubsection{OpenVR}
OpenVR ist eine API, welche den direkten Zugriff auf VR-Hardware von verschiedenen Anbietern, wie Oculus, Mixed Reality und Vive, ermöglicht.
Hierbei benötigt die Anwendung keine speziellen Kenntnisse über die Hardware.
OpenVr besteht aus der Applikation und dem Treiber, welche über SteamVR miteinander kommunizieren.
Die API besteht aus mehreren C++ Interface Klassen.
Wenn die Applikation ausgeführt wird, liefert OpenVR, je nach vorhandenem SDK, das benötigte Interface zurück.
~\cite{OpenVR_Github_Documentation_2020}

%%\subsubsection{OpenVR Treiber}

%%~\cite{OpenVR_SteamWorks_Documentation_2020}


%%\subsection{Steam}\label{subsec:steam}

%%\subsection{Vive Wireless}

\subsection{Final IK Plugin}
Final IK ist ein Unity Asset, welches von RootMotion entwickelt wurde.
Es wurde kostenlos für die Erstellung von BeamVR bereitgestellt und regelt das Full Body Tracking.
Hierbei wird das Full Body Biped IK, welches inbegriffen ist, verwendet.
~\cite{FinalIK_Overview_2020}

\subsubsection{AimIK}
AimIK rotiert die Knochen des 3D-Modells, so dass auf ein Objekt gezielt werden kann.
Es wird hierbei nicht die eingebaute LookAt Funktion des Animators benutzt, da die Objekte mit denen gezielt wird, nicht mit den Achsen des Modells übereinstimmen.
AimIK ermöglicht ein natürlich aussehendes Ergebnis, selbst wenn sich das Ziel beinahe hinter dem zielendem Objekt befindet.
Rotation limits verhindern, dass das Skelett in unnatürliche Bewegungen und Stellungen verändert wird.
Bei menschenähnlichen Modellen, limitiert diese Einstellung die Gelenke auf die gleichen Bewegungsmöglichkeiten wie bei einem Menschen, siehe Abb. ~\ref{fig:finalIK_aimIK_pose}.
Diese können jedoch frei verändert werden, was jedoch zu unrealistischen Posen führen kann.
\begin {figure}
    \centering
    \includegraphics[scale=0.4]{pics/finalik_aimik_pose}
    \caption{Final IK - AimIK Pose}
    \label{fig:finalIK_aimIK_pose}
\end {figure}

Damit die Berechnung der Pose funktioniert, werden mehrere verschiedene Einstellungsmöglichkeiten bereitgestellt, siehe Abb. ~\ref{fig:finalIK_aimIK_script}.
Um zu wissen worauf gezielt werden soll, muss zuerst ein Ziel festgelegt werden, dies ist möglich bei der Variable Target.
Aim Transform ist das Objekt, mit welchem gezielt werden soll.
Dabei kann es sich um viele verschiedene Objekte, wie Waffen oder ein Hand die auf etwas zeigen soll, handeln.
Axis gibt an in welche Richtung das Objekt zielt.
Wenn zum Beispiel ein Laserpointer den Laser in Richtung der Z-Achse abstrahlt muss die Achse auf (0,0,1) gesetzt werden, da das Schema (x,y,z) ist.
Damit die richtigen Knochen bewegt werden, wenn auf ein Ziel gezielt wird, müssen diese bei Bones Definiert werden.
Das Wight steuert wie stark die veränderungen des Scripts auf die tatsächliche Position des Knochen einwirken sollen.
Bei 0 wird der Knochen kaum bis garnicht verändert, wenn der Wert jedoch 1 ist, wird die ursprüngliche Position komplett verändert.
\begin {figure}
    \centering
    \includegraphics[scale=0.7]{pics/finalik_aimik_script}
    \caption{Final IK - AimIK Script}
    \label{fig:finalIK_aimIK_script}
\end {figure}
~\cite{FinalIK_AimIK_2021}

\subsubsection{Arm IK}
ArmIK stellt die Position und Rotation der Knochen eines Armes so ein, dass die Hand möglichst nahe an der Zielposition platziert ist.
Hierfür werden 5 Knochen benötigt, Chest, Shoulder, Upper Arm, Forearm und Hand, siehe Abb. ~\ref{fig:finalIK_armIK_script}.
Chest befindet sich im Oberkörper des Modells und ist am nähesten am Arm dran.
Shoulder ist der Schulterknochen, Upper Arm ist der Oberarm Knochen, Forearm ist der Unterarm Knochen und Hand befindet sich in der Hand.
Hierbei werden die Finger nicht beachtet, da es nur um die Berechnung der Position des Armes handelt.
Mithilfe der Target Variable wird erneut ein Ziel festgelegt, welches die Zielposition der Hand angiebt.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/finalik_armik_script}
    \caption{Final IK - ArmIK Script}
    \label{fig:finalIK_armIK_script}
\end {figure}
~\cite{FinalIK_ArmIK_2021}

\subsubsection{Baker}
Der Baker ist ein Tool welches die Aufnahme von Animations Clips ermöglicht.
Um humanoide Modelle aufzunehmen, muss das Humanoid Baker Script zu dem Animierten Objekt hinzugefügt werden, siehe Abb. ~\ref{fig:finalIK_humanoid_baker}.
Für andere Modelle wird das Generic Baker Script benötigt, siehe Abb. ~\ref{fig:finalIK_generic_baker}.
Wenn die Applikation in Unity ausgeführt wird, kann in beiden Scripten auf Bake Animation States gedrückt werden.
Nun werden die Animationen in einen vorher ausgewählten Ordner abgespeichert und können jederzeit wiederverwendet werden.

\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/finalik_baker_HumanoidBakerComponent}
    \caption{Final IK - Humanoid Baker}
    \label{fig:finalIK_humanoid_baker}
\end {figure}
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/finalik_baker_GenericBakerComponent}
    \caption{Final IK - Generic Baker}
    \label{fig:finalIK_generic_baker}
\end {figure}
~\cite{FinalIK_Baker_2021}

\subsubsection{Biped IK}
Biped IK erlaubt die Modifikation der Position und Rotation der Knochen, eines Modelles mit 2 Beinen, 2 Armen und einem Kopf.
Das Script erkennt die Knochen automatisch und ist sofort einsatzbereit.
Seit FinalIK 4.0 wird jedoch FullBodyBiped IK empfohlen, da dieses eine leichtere Optimierung der IK eines Modelles erlaubt.

Es können wie bei vorherigen Funktionen, Animationen beliebig überschrieben werden, ohne diese tatsächlich ändern zu müssen.
BipedIK bietet die Möglichkeit jedes Glied, also Kopf, Füße, Arme, Ober- und Unterkörper, einzeln einzustellen, siehe Abb. ~\ref{fig:finalIK_bipedik_script}.
Weiters kann wieder ein Ziel festgelegt werden, falls der Charakter auf einen Gegenstand zielen soll.
\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/finalik_bipedik_script}
    \caption{Final IK - BipedIK Script}
    \label{fig:finalIK_bipedik_script}
\end {figure}
~\cite{FinalIK_BipedIK_2021}

\subsubsection{CCD IK}
Cyclic Coordinate Descent, auch als CCD bezeichnet, ist ein viel genutzter und bekannter Anwendungsfall von IK.
Dieses Skript richtet die einzelnen Gelenke nacheinander in Richtung der Zielposition aus.
Durch das ständige Widerholen dieser Aktion wird die Kette an Gelenken und Knochen richtig ausgerichtet.
Damit die Gelenke nicht unnatürliche Positionen einnehmen, kann ein Rotationslimit festgelegt werden, dieses kann nicht überschritten werden und sorgt für zusätzlichen Realismus.
Für längere Ketten an Gelenken wird empfohlen FABRIK zu verwenden.
Ein Anwendungsfall für dieses Skript ist zum Beispiel ein Roboter oder andere Lebewesen, welche auf einem unebenen Gelände, mit ihren Beinen auf dem Boden stehen sollen, siehe Abb. ~\ref{fig:finalIK_ccd_robot_example}.
Mit CCD ist es Möglich die Beine so auszurichten, dass der Boden mit allen Gliedern berührt wird, ohne die Animationen anpassen zu müssen.
\begin {figure}
    \centering
    \includegraphics[scale=0.4]{pics/finalik_ccd}
    \caption{Final IK - CCD Robot Example}
    \label{fig:finalIK_ccd_robot_example}
\end {figure}
~\cite{FinalIK_CCD_2021}

\subsubsection{FABRIK}
Fabrik kann auf einer beliebigen Anzahl an Knochen-Segmenten mit Rotations-Limits verwendet werden.
Es benutzt eine Methode welche die neue Position von Gelenken in beide Richtungen, also Vorwärts und Rückwerts,
von einem Gelenk zum nächsten, berechnen kann.

Ein Vorteil von FABRIK ist, dass die Knochenlängen während der Laufzeit verändert werden können,
die Änderungen werden automatisch erkannt und neu berechnet. Ein Anwendungsfall für Fabrik ist in Abb. ~\ref{fig:finalIK_fabrik_example} zu sehen.
\begin {figure}
    \centering
    \includegraphics[scale=0.4]{pics/finalik_fabrik_pose}
    \caption{Final IK - Fabrik Example}
    \label{fig:finalIK_fabrik_example}
\end {figure}

Damit Fabrik benutzt werden kann, werden mehrere Variablen benötigt, siehe Abb. ~\ref{fig:finalIK_fabrik_script}.
Target, beschreibt die Position eines Zieles, zu welchem sich der Arm bewegen soll.
Die Position aller Knochen und Gelenke richtet sich automatisch so aus, dass der Arm auf das Ziel zeigt.

Weight kann dazu benutzt werden, um die Änderungen von Fabrik ein- und auszublenden. Ein Wert von 1 bedeutet,
dass alle Änderungen mit voller Kraft vorgenommen werden, wird der Wert nun näher an 0 gesetzt,
werden die Effekte nicht mehr übernommen.

Tolerance gibt die minimale Distanz an, welche die Zielposition bewegt werden muss,
bevor Fabrik die Berechnung aller Gelenke erneut startet. Liegt die Positionsänderung unter dem
Toleranzbereich wird nichts unternommen.

MaxIterations gibt die maximale Anzahl an Iterationen, welche in einem Frame durchgeführt werden dürfen.
Während den Iterationen wird die Position der Knochen und Gelenke berechnet.

UseRotationLimits gibt an, ob die Rotationslimits auf den Einzelnen Knochen bei der Berechnung der Position
miteinbezogen werden sollen, oder nicht.

Bei Bones, handelt es sich um eine Liste, welche alle Knochen beinhalten soll, die bei der Berechnung der
Positionen und Rotationen, herangezogen werden sollen.
~\cite{FinalIK_FABRIK_2021}
\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/finalik_fabrik_script}
    \caption{Final IK - Fabrik Script}
    \label{fig:finalIK_fabrik_script}
\end {figure}


\subsubsection{FABRIK Root}
Fabrik Root ist ein Component, welcher mehrere einzelne Fabrik Ketten miteinander verbinden lässt.
Hierbei kann es sich um kompliziertere Systeme mit mehreren Abzweigungen handeln, siehe Abb. ~\ref{fig:finalIK_fabrik_root_example}

\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/finalik_fabrik_root_example}
    \caption{Final IK - Fabrik Root Script}
    \label{fig:finalIK_fabrik_root_example}
\end {figure}

Damit Fabrik Root richtig funktioniert müssen, ähnlich wie bei Fabrik, verschiedene Variablen angegeben werden,
siehe Abb. ~\ref{fig:finalIK_fabrik_root_script}.

Weight wird benutzt, um die Änderungen von FabrikRoot und Fabrik ein- und auszublenden.
Ein Wert von 1 bedeutet, dass alle Änderungen mit voller Kraft vorgenommen werden, wird der Wert nun auf 0 gesetzt,
werden die Effekte nicht mehr übernommen.

Iterations gibt die Anzahl an Iterationen, welche in einem Frame durchgeführt werden dürfen, an.
Hierbei wird in jeder Iteration die Position und Rotation aller angegebenen Fabrik Ketten berechnet.

RootPin befestigt die Fabrik Ketten an einen Bestimmten Ort, welcher zum Beispiel auf einem Objekt,
oder irgendwo in der Luft platziert werden kann. Dieser Punkt kann nicht durch die Fabrik Ketten bewegt werden.

Chains ist eine Liste an Fabrik.
IK gibt den Fabrik Komponent an, welcher die Position und Rotation einer Knochenkette berechnet.

Pull gibt an wie stark diese Kette die, in der Hierarchie übergestellte, Kette bewegen darf.

Pin gibt an, wie stark die Kette von einer Kette, welche in der Hierarchie untergeordnet ist, bewegt werden kann.

Children ist eine Liste von Indizes, welche auf die, in der Hierarchie untergeordneten, Fabrik verweist.

\begin {figure}
\centering
\includegraphics[scale=0.5]{pics/finalik_fabrik_root_script}
\caption{Final IK - Fabrik Root Script}
\label{fig:finalIK_fabrik_root_script}
\end {figure}

\subsubsection{Full Body Biped IK}
\subsubsection{Grounder}
\subsubsection{Interaction System}
\subsubsection{Leg IK}
\subsubsection{Limb IK}
\subsubsection{Look At IK}
\subsubsection{Rotation Limits}
\subsubsection{Trigonometric IK}
\subsubsection{VRIK}
\subsubsection{Extending Final IK}


\subsection{IDE}

\subsection{Modellierung}
