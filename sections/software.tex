\section{Game Engine}\label{sec:game-engine}

Es gibt mehrere Games Engines mit welchen eine VR Applikation entwickelt werden kann.
In Abb.~\ref{fig:game_engine_marketshare} ist der Marktanteil verschiedener Engines abgebildet.
Diese Daten sind aber mit Vorsicht zu genießen, da das Skript welche diese Daten geliefert hat nach einigen Kriterien handelt,(siehe~\cite{REDDIT_2018}).
Dies bedeutet beispielsweise, dass nur Spiele mit einer Wikipedia Seite mit einberechnet werden.

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{pics/game_engine_marketshare}
    \caption{Game Engine Market-share~\cite{REDDIT_2018}}
    \label{fig:game_engine_marketshare}
\end{figure}

\begin{figure}
    \includegraphics[scale=0.4]{pics/programming_languages_hardest}
    \caption{Schwerste Programmiersprachen~\cite{JAXCENTER_2018}}
    \label{fig:hardest_programming_languages}
\end{figure}

\subsection{Unity}\label{subsec:unity}

Unity ist eine Game Engine, welche von Unity Technologies initial exklusiv für Apple Mac OS X entwickelt wurde.
Die Engine wurde portiert und kann heute auch auf Windows und auf der Linux Plattform benützt werden.
Sie ist für alle im prinzip gratis bis zu einem bestimmten Umsatz.
Auch wenn sie eine Einsteiger Engine genannt wird, ist sie trotzdem im professionellen Bereich in benutzung und viele bekannte Spiele, wie Pokemon GO, Among us und Hearthstone wurden in der Unity Engine entwickelt~\cite{Haas2014AHO,Unity_System_Specification,UNITY_PRICING_1,WIKIPEDIA_UNITY_GAME_LIST_2014}.

\subsubsection{Vorteile}\label{subsubsec:vorteile}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{pics/mobile_os_marketshare}
    \caption{Mobile Betriebssystem Market Share~\cite{StatCounter_Mobile_2021}}
    \label{fig:mobile-os-market-share}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{pics/desktop_os_market_share}
    \caption{Desktop Betriebsystem Market Share~\cite{StatCounter_Desktop_2021}}
    \label{fig:desktop-os-market-share}
\end{figure}



\begin{itemize}
    \item \textbf{Leichter Einstieg:} Das Einsteigen in Unity ist ein sehr einfacher Prozess.
    Die einzige Voraussetzung für den Start einer Unity Applikation ist ein Unity Account.
    Nach der Erstellung eines Accounts kann das Unity Hub heruntergeladen werden.
    Anschließend kann in dem Unity Hub eine Version der Unity Engine heruntergeladen werden~\cite{Unity_Download}.
    Anfangs ist die Engine gratis, fallen nach einem bestimmten Umsatz an~\cite{Unity_Pricing_2}.
    \item \textbf{Programmiersprache:} In Abb.~\ref{fig:hardest_programming_languages} ist ersichtlich, dass viele Programmierer der Meinung sind, C\# einer der einfacheren zu lernenden Sprachen ist.
    Verglichen mit den C++, welches die Programmiersprache der Unreal Engine ist, hat sie nach der Abb. eine weitaus kleinere Lernkurve.
    \item \textbf{Plattform Kompatibilität:} Applikationen, welche in Unity entwickelt worden sind haben eine hohe Plattformunabhängigkeit.
    Unity Applikationen können für die größten Desktop- und Mobile Betriebssysteme gebaut werden.
    Siehe dazu Abb.~\ref{fig:desktop-os-market-share} und Abb.~\ref{fig:mobile-os-market-share}.
    Für eine volle Liste der unterstützten Plattformen wird auf~\cite{UNITY_PLATTFORMS} verwiesen.
\end{itemize}

\subsubsection{Nachteile}

\begin{itemize}
    \item \textbf{Market Share:} Nach Abb.~\ref{fig:game_engine_marketshare} hat die Unity Engine weniger Market-share wie beispielsweise die Unreal Engine.
    \item \textbf{Kostenanfall:} Es ist in~\cite{UNREAL_ENGINE_PRICING_2022} und~\cite{Unity_Pricing_2} ersichtlich, dass bei Unity schneller Kosten anfallen wie bei der Unereal Engine.
    Das bedeutet nicht, dass die Kosten bei Unity mehr sind wie bei Unreal Engine, sondern, dass die kostenlose Entwicklungsphase bei Unreal länger ist.
\end{itemize}

\subsection{Unreal Engine}
\label{subsec:unreal_engine}

Unreal Engine wird von Epic Games entwickelt~\cite{UNEAL_ENGINE_OWNER_2022}.
Diese Engine ist eine weit verbreitete Game Engine.
Dies kann man Abbildung~\ref{fig:game_engine_marketshare} entnehmen.
Viele Spiele wie Fortnite, Ark Survival Evolved, Borderlands 3 und Jedi Fallen Order sind mit dieser Engine entwickelt worden~\cite{WIKIPEDIA_UNREAL_GAME_LIST}.

\begin{figure}
    \centering
    \includegraphics[scale=0.3]{pics/visual_scripting_unreal_engine}
    \caption{Visual Scripting in Unreal Engine 5}
    \label{fig:visual_scripting_unreal_engine}
\end{figure}

\subsubsection{Vorteile}

\begin{itemize}
    \item \textbf{Market Share:} In Abb.~\ref{fig:game_engine_marketshare} ist ersichtlich, dass Unreal den Größten Market Share.
    Dies ist genauso wie zuvor mit Vorsicht zu genießen, da diese Daten wie bereits beschrieben unter einem bestimmten Kriterium gesammelt worden sind.
    \item \textbf{Visual Scripting:} Unreal Engine benutzt für das Scripting der Applikation neben der Programmiersprache C++ ein visual scripting System, welches auch Blueprint genannt wird.
    Anders wie in Bolt, welches das Visual Scripting Tool für Unity ist, ist das Blueprint System bereits eingebaut.
    Bolt muss noch extra installiert und konfiguriert werden~\cite{Unity_Bolt}.
    Das integrierte Blueprint System hat seine Nachteile und seine Vorteile.
    Ein Vorteil ist die abgeschwächte Lernkurve, die das System gegenüber von C++ bietet um die Unreal Engine kennenzulernen.
    Dies zumindest nach~\cite{Mower_UnrealEngine} und~\cite{jwatte_2017}.
    ~\ref{fig:visual_scripting_unreal_engine}
    \item \textbf{Kostenanfall:} Wie bereits bei den Nachteilen der Unity Engine besprochen fallen die Kosten bei der Unreal Engine langsamer and wie bei der Unity Engine..\cite{UNREAL_ENGINE_PRICING_2022, Unity_Pricing_2}
\end{itemize}

\subsubsection{Nachteile}

\begin{itemize}
    \item \textbf{Unterstützte Spielplattformen:} Applikationen, welche mit Unreal Engine gemacht worden sind können für weniger Plattformen entwickelt werden wie bei der Unity Engine~\cite{Viscirele_Unreal_v_Unity}.
    \item \textbf{Unterstützte Entwicklerplattformen:} Mit der Unreal Engine ist es möglich auf den drei größten Desktop Betriebssystemen, welche in Abb.~\ref{fig:desktop-os-market-share} ersichtlich sind, zu entwickeln.
    Dennoch ist es komplizierter die Game Engine auf Linux zu installieren, da man hier die Game Engine selber von der Quelle bauen muss.
    Es gibt keinen offiziellen Binary Installer für Linux~\cite{Unreal_Installationsguide}.
    \item \textbf{C++:} Für erweiterte Funktionalität, welche nicht mit dem Blueprint System implementiert, werden kann, muss auf C++ zurückgegriffen werden.
    In Abb.~\ref{fig:hardest_programming_languages} ist zu sehen, dass C++ eine starke Lernkurve hat.
\end{itemize}

\subsection{Source Engine und Source 2 Engine}
\label{subsec:source-engine-und-source-2-engine}

Es gibt mittlerweile 2 Iterationen dieser Engine.
Zum einen die originale Source Engine und die Source Engine 2.
Die Markteinführung der ursprünglichen Source Engine war im Juni 2004~\cite{Bryan_Wirtz_SOURCE_ENGINE_2022}.
Daraufhin ist die Source 2 Engine im August 2014 erschienen~\cite{VALVE_DEVELOPER_COMMUNITY_SOURCE2}.
Beide Engines sind von Valve entwickelt worden~\cite{VALVE_DEVELOPER_COMMUNITY_SOURCE, VALVE_DEVELOPER_COMMUNITY_SOURCE2}.
Verantwortlich ist die Source 2 Engine für Spiele wie Dota 2 und Half Life Alyx~\cite{WIKIPEDIA_SOURCE2_ENGINE_GAME_LIST}.
Andere Spiele wie Half Life 2, Counterstrike Source, Portal, Portal 2 und Counterstrike Global Offensive sind mit der originalen Source Engine entwickelt worden~\cite{WIKIPEDIA_SOURCE_ENGINE_GAME_LIST}.
Auch als VR Entwicklungsumgebung eignet sich die Source 2 Engine, da sie für Half Life: Alyx, eines der erfolgreichsten VR Spiele benutzt worden ist~\cite{WIKIPEDIA_SOURCE2_ENGINE_GAME_LIST, Aden_Carter_2020}.
Die folgenden Vorteile und Nachteile beziehen sich auf die Source 2 Engine.

\subsubsection{Vorteile}

\begin{itemize}
    \item \textbf{Gratis:} Die Source Egnine ist grundsätzlich komplett Gratis.
    Es gibt keine Kostenanfälle durch das nutzen der Engine.
    Das einzige Kriterium von Valve ist, dass die Engine auf Steam publiziert werden muss~\cite{Brenna_Hillier_2015}.
\end{itemize}


\subsubsection{Nachteile}\label{pgr:cons}

\begin{itemize}
    \item \textbf{Market Share:} In Abb.~\ref{fig:game_engine_marketshare} ist ersichtlich, dass die Source Engine verglichen mit den zuvor gennanten Game Engines keinen großen Marktanteil hat.
    Weniger Nutzung einer Engine bedeutet auch weniger unterstützung, welche es online zur Verfügung gibt.
    \item \textbf{Publizierung:} Wie bereits bei den Vorteilen angesprochen, muss ein Spiel, welches mit der Source Engine entwickelt worden ist auch auf Steam publiziert werden~\cite{Brenna_Hillier_2015}.
\end{itemize}

\section{VR in Unity}\label{sec:vr-in-unity}
\setauthor{Florian Beckerle}
Unity bietet bereits eine eingebaute Basis VR API, welche ein paar Features für die Verwendung von VR Geräten zur Verfügung stellt.
Diese muss jedoch erst eingstellt werden, das geht in folgenden Schritten.

Um VR für die Spiele zu aktivieren, müssen zuerst die Player Settings, welche im Menü bei Edit > Project Settings > Player zu finden sind, geöffnet werden.
Als nächstes muss die Option Virtual Reality Supported aktiviert werden, sodass in der Box ein Haken zu erkennen ist, siehe Abb. ~\ref{fig:unity_vr_api_settings}.
In der darunter stehenden Liste, namens Virtual Reality SDKs, kann nun mit dem Plus-Knopf eine neue SDK hinzugefügt werden.
Ein Beispiel hierfür wäre die Oculus SDK.
Der Minus-Knopf bietet die Möglichkeit, diese SDKs wieder zu entfernen, siehe Abb. ~\ref{fig:unity_vr_api_settings}.
~\cite{Unity_VR_Overview_2022}

Wenn VR aktiviert wurde, wird das Spiel automatisch auf die VR-Brille gerendert und dort angezeigt.
Weiters besitzt jede Kamera, welche im Spiel ist, eine Option, auf welches Auge das Ausgangssignal angezeigt werden soll, zum Beispiel linkes-, rechtes-, beide- oder keine Augen.
Unter den Augen versteht man die Bildschirme der VR-Brille welche sich vor den Augen des Benutzers befinden.
Ein weiteres automatisches Feature ist, dass die Bewegung der VR-Brille, in der Realtität auf die Position der Kamera im Spiel übertragen wird.

Unity empfiehlt für die Verwendung der Api folgende Brillen: Gear VR, Oculus CV1 und die Vive.
~\cite{Unity_VR_Overview_2022}

\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/unity_basis_vr_api_settings}
    \caption{Unity VR API - Settings}
    \label{fig:unity_vr_api_settings}
\end {figure}

\section{VR Plugin}\label{sec:vr-plugin}
\setauthor{Florian Beckerle}
Für BeamVR wurde das SteamVR Unity Plugin verwendet.
Es wurde von Valve entwickelt und bietet bereits eine Vielzahl an vorgefertigten Demos, welche mit der Installation des Plugins mitgeliefert werden, diese werden später genauer beschrieben.
~\cite{SteamVR_Overview_2022}

\subsection{Quickstart}\label{subsec:quickstart}
\setauthor{Florian Beckerle}
Für das Setup des SteamVR Unity Plugins sind 5 Schritte notwendig.
Damit alles funktioniert muss SteamVR von Steam und das Plugin vom Unity Asset Store gedownloaded werden.
Nachdem die Installation beider Softwares abgeschlossen wurde, muss das Plugin über den Package Manager in das Unity Projekt importiert werden.
Im Menu Window wird nun eine neue Option namens SteamVR Input angezeigt, siehe Abb. ~\ref{fig:steamvr_input_menu_item}.
\begin {figure}
    \centering
    \includegraphics[scale=0.9]{pics/steamVR_Input_MenuItem}
    \caption{Steam VR - Input Menu Item}
    \label{fig:steamvr_input_menu_item}
\end {figure}
Wenn man auf diese klickt, erscheint ein Popup, welches fragt, ob JSON Files kopiert werden sollen, dort drückt man auf Ja, siehe Abb. ~\ref{fig:steamvr_copy_json}.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_Input_CopyJSON}
    \caption{Steam VR - Copy JSON}
    \label{fig:steamvr_copy_json}
\end {figure}
Nachdem der Vorgang abgeschlossen ist, öffnet sich das SteamVR Input Fenster, dort muss nun Save and Generate gedrückt werden, siehe Abb. ~\ref{fig:steamvr_save_and_generate}.
\begin {figure}
    \centering
    \includegraphics[scale=0.6]{pics/steamVR-Input-SaveAndGenerate}
    \caption{Steam VR - Save and Generate}
    \label{fig:steamvr_save_and_generate}
\end {figure}
Nun ist die Installation abgeschlossen und das SteamVR Unity Plugin ist einsatzbereit.
~\cite{SteamVR_Quickstart_2022}

\subsection{Render Models}\label{subsec:render-models}
\setauthor{Florian Beckerle}
Das SteamVR Unity Plugin bietet eine virtuelle Darstellung der Kontroller, welche der Benutzer in den Händen hält.
Die gezeigten Modelle benötigen hierfür mehrere Attribute, siehe Abb. ~\ref{fig:steamvr_render_models Script}.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_render_models_script}
    \caption{Steam VR - Render Models Script}
    \label{fig:steamvr_render_models Script}
\end {figure}
Der Index ist der Index des getrackten Gerätes, und wird vom System wie eine ID zur Erkennung verwendet.
Mittels dem Model Override kann man für Testzwecke ein bestimmtes Modell festlegen, welches angezeigt werden soll.
Die Shader können die Darstellung des Objektes verändern.
Verbose gibt die Vorgänge im Script in der Konsole aus, diese Option wird jedoch nur für das Testen benötigt.
Create Components erstellt individuelle Objekte für jede Komponente, welche verfügbar ist.
Update Dynamically bewegt die einzelnen Komponenten gleich wie die physischen Gegenstücke.
~\cite{SteamVR_Render_Models_2022}

\subsection{Input}\label{subsec:input}
\setauthor{Florian Beckerle}
Die Hardware für VR Geräte schnell weiterentwickelt wird, hat Valve auf ein KeyBinding System zurückgegriffen.
Die Entwickler und die Benutzer selbst können für neue oder bereits vorhandene Hardware einstellen, welche Funktion die einzelnen Knöpfe und Trigger haben.
Diese Aktionen wurden in 6 verschiedene Input Typen und einen Output Typen aufgeteilt.

Die Aktion Boolean besitzt zwei Zustände, true und false.
Sie wird oft benutzt, um Objekte zu greifen, da man zum Beispiel einen Würfel entweder aufheben können soll oder nicht.

Single Aktionen können analoge Werte zwischen 0 und 1 annehmen und wird für Situationen benutzt, in denen der Boolean nicht ausreicht.
Ein Anwendungsfall ist ein Auto, welches bei 0 stehen bleibt und bei 1 Vollgas fährt.
Als Eingabe kann zum Beispiel der Trigger des Kontrollers benutzt werden.

Vector2 besitzt zwei Werte, X und Y.
Die Bewegungen des Kontrollers werden hierbei nur auf zwei Achsen gemessen.

Vector3 besitzt im Gegensatz zu Vector2 drei verschiedene Werte X, Y und Z.
Diese Aktion wird selten benutzt, findet aber zum Beispiel im SteamVR Home einen Anwendungsfall beim Scrollen.

Pose gibt die Position und Rotation in einem dreidimensionalen Raum wieder.
Es wird dazu benutzt, um die Bewegungen der Controller zu messen und digital nachzubilden.

Skeleton benutzt das SteamVR Skeleton Input, um die ungefähre Position und Rotation der Finger zu erkennen, während der Kontroller in den Händen gehalten wird.

Vibrationen werden für haptisches Feedback bei VR Geräten verwendet.
Hierbei vibrieren der Kontroller, eine spezielle Haptik Weste oder ein präparierter Sessel.
~\cite{SteamVR_Input_2022}

\subsection{Skeleton Input}\label{subsec:skeleton-input}
\setauthor{Florian Beckerle}
Das Plugin bietet die Möglichkeit, Hände mit Fingern und deren aktuelle Position darzustellen.
Die Bewegungen werden hierbei zwischen zwei verschiedenen Begrenzungen der Fingerpositionen unterschieden.
WithController berechnet eine ungefähre Position der Finger, während diese einen Kontroller in den Händen halten.
Dies dient besonders dazu, die Interaktion zwischen der realen Hand und dem realen Kontroller digital darzustellen.
WithoutController bietet die Bewegungen von Fingern, wenn sie keinen Kontroller in der Hand halten.
In der Realtität kann währenddessen jedoch trotzdem ein Kontroller gehalten werden, es wird nur digital nicht angezeigt, siehe Abb. ~\ref{fig:steamvr_skeletal_input_models}.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_skeletal_input_models}
    \caption{Steam VR - Skeletal Input Models}
    \label{fig:steamvr_skeletal_input_models}
\end {figure}
Die Positionen der Finger werden relativ zu dem in der Hierarchie übergestuften Objekt und dem Model gemessen.
Jeder Finger besteht hierbei standardmäßig aus 4 Gelenken.
Ein Wert im Bereich von 0 bis 1 gibt an, wie stark die Finger eingerollt sein sollen.
Die Finger einer Hand sind bei SteamVR etwas auseinandergestpreizt, hier wird ebenfalls ein Wert von 0 bis 1 dazu verwendet, um die Distanz zwischen den Fingern zu verändern.

Um die Position der Finger zu messen, gibt es grundsätzlich drei verschiedene Methoden.
Bei Estimated kann die Position des Körperteiles nicht direkt bestimmt werden.
Jede Bewegung wird nur über die Bediehnung der Trigger, Knöpfe und Trackpads des Kontrollers gestimmt.
Partial kann die Bewegungen der Finger direkt bestimmen, jedoch nur eingeschränkter als die tatsächlichen Finger.
Die Positionen werden durch andere Werte, wie zum Beispiel von speziellen Handschuhen, gemessen.
Full kann die komplette Körperbewegung des Benutzers messen, wie zum Beispiel durch Motion Caputre Anzüge oder Handschuhe.

Das Script, welches für die Bewegung des Modelles zuständig ist, besitzt eine Vielzahl an verschiedenen Optionen, siehe Abb. ~\ref{fig:steamvr_skeletal_input_Script}.
Update Pose setzt die Position und Orientierung des Objektes neu, sobald der Controller bewegt wurde.
Mirroring gibt an, ob die Knochen Daten entlang der X-Achse gespiegelt werden sollen.
Die Blend Optionen bieten Einstellungsmöglichkeiten, um den Übergang zwischen Verschiedenen Bewegungsmöglichkeiten und Animationen zu verändern.
Weiters kann man einen bestimmten Knochen mittels GetBonePosition bekommen und die Positionen und Rotationen werden mittels GetBonePositions und GetBoneRotations bereitgestellt.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/steamVR_skeletal_input_script}
    \caption{Steam VR - Skeletal Input Script}
    \label{fig:steamvr_skeletal_input_Script}
\end {figure}
~\cite{SteamVR_Skeleton_Input_2022}

\subsection{Interaction System}\label{subsec:interaction-system}
\setauthor{Florian Beckerle}
Das Interaction System funktioniert mittels dem Senden von Nachrichten an Objekte, mit welchen die Hände des Spielers oder andere Objekte interagieren.
Diese Objekte können sich an die Hand anheften und somit gehalten werden.
Das System bietet die Möglichkeit, Maus Events nachzuahmen, somit funktioniert die Interaktion mit der Benutzeroberfläche auch in VR.

Die Player Klasse weiß, wo die VR-Brille und die Kontroller positioniert sind.
Mittels der Methoden hmdTransform und feetPositionGuess können die Positionen der Brille und eine Schätzung der Fußstellung zurückgeliefert werden.

Die Hand Klasse wird für die meisten Funktionen des Interaction Systems benötigt.
Sie sendet interagierbaren Objekten Nachrichten über den aktuellen Status der Hand.
Sie kann nur mit einem Objekt gleichzeitig direkt interargieren, darunter versteht man das Aufheben und Werfen dieser.
Objekte können an die Hand angebracht und wieder losgelöst werden.
Das Verhalten der Hände kann durch sogenannte AttachmentFlags verändert werden, welche bei einer Interaktion aktiviert werden.

Interactable Objekte können von Spielern aufgehoben werden, solange ein bestimmter Knopf gedrückt wird.
Befindet sich die Hand, während dieser Knopf losgelassen wird, in Bewegung wird die Geschwindigkeit und die Richtung auf das Objekt übertragen und es wird geworfen.
%%Optional noch andere Scripts erklären falls notwendig, erscheinen jedoch nicht sonderlich wichtig (wichtigere noch mit !)
%    Throwable
%    LinearDrive
%    CircularDrive
%    LinearMapping
%    VelocityEstimator !!
%    IgnoreHovering
%    UIElement
%    ItemPackage
%    ItemPackageSpawner
%    ItemPackageReference
%    PlaySound
%    SoundPlayOneShot
%    Util
%    InteractableHoverEvents
%    InteractableButtonEvents
%    ComplexThrowable
%    DistanceHaptics
%    Player (Prefab) !!
%    BlankController (Prefab)
%    Teleport !!
%    Render Model
%    Hints
%    Samples
~\cite{SteamVR_Interaction_System_2022}

\subsection{Skeleton Poser}\label{subsec:skeleton-poser}
\setauthor{Florian Beckerle}
Der Skeleton Poser funktioniert mithilfe von verschiedenen Posen, welche erstellt und eingefügt werden können.
Mittels dem Blending Editor des Posers kann zwischen verschiedenen Posen ein Übergang erstellt werden.

Hierbei existieren 4 Modi für die Fingerbewegungen.
Der Static Modus erlaubt keine Fingerbewegungen und beachtet nur die Posen.
Bei Free können die Finger frei bewegt werden und die Pose wird ignoriert.
Mittels Extend können die Finger komplett ausgestreckt werden, aber nur nicht weiter eingerollt werden, als es bei der Pose eingestellt wurde.
Bei Contract können die Finger ganz eingerollt werden, jedoch nicht weiter ausgestreckt werden als bei der Pose.
~\cite{SteamVR_Skeleton_Poser_2022}

\subsection{OpenVR}\label{subsec:openvr}
OpenVR ist eine API, welche den direkten Zugriff auf VR-Hardware von verschiedenen Anbietern, wie Oculus, Mixed Reality und Vive, ermöglicht.
Hierbei benötigt die Anwendung keine speziellen Kenntnisse über die Hardware.
OpenVr besteht aus der Applikation und dem Treiber, welche über SteamVR miteinander kommunizieren.
Die API besteht aus mehreren C++ Interface Klassen.
Wenn die Applikation ausgeführt wird, liefert OpenVR, je nach vorhandenem SDK, das benötigte Interface zurück.
~\cite{OpenVR_Github_Documentation_2020}

\section{Final IK Plugin}\label{sec:final-ik-plugin}

Final IK ist ein Unity Asset, welches von RootMotion entwickelt wurde.
Es wurde kostenlos für die Erstellung von BeamVR bereitgestellt und regelt das Full Body Tracking.
Hierbei wird das Full Body Biped IK, welches inbegriffen ist, verwendet.
~\cite{FinalIK_Overview_2020}

\subsection{AimIK}\label{subsec:aimik}
AimIK rotiert die Knochen des 3D-Modells, sodass auf ein Objekt gezielt werden kann.
Es wird hierbei nicht die eingebaute LookAt Funktion des Animators benutzt, da die Objekte, mit denen gezielt wird, nicht mit den Achsen des Modells übereinstimmen.
AimIK ermöglicht ein natürlich aussehendes Ergebnis, selbst wenn sich das Ziel beinahe hinter dem zielendem Objekt befindet.
Rotation limits verhindern, dass das Skelett in unnatürliche Bewegungen und Stellungen verändert wird.
Bei menschenähnlichen Modellen limitiert diese Einstellung die Gelenke auf die gleichen Bewegungsmöglichkeiten wie bei einem Menschen, siehe Abb. ~\ref{fig:finalIK_aimIK_pose}.
Diese können jedoch frei verändert werden, was jedoch zu unrealistischen Posen führen kann.
\begin {figure}
    \centering
    \includegraphics[scale=0.4]{pics/finalik_aimik_pose}
    \caption{Final IK - AimIK Pose}
    \label{fig:finalIK_aimIK_pose}
\end {figure}

Damit die Berechnung der Pose funktioniert, werden mehrere verschiedene Einstellungsmöglichkeiten bereitgestellt, siehe Abb. ~\ref{fig:finalIK_aimIK_script}.
Um zu wissen worauf gezielt werden soll, muss zuerst ein Ziel festgelegt werden, dies ist möglich bei der Variable Target.
Aim Transform ist das Objekt, mit welchem gezielt werden soll.
Dabei kann es sich um viele verschiedene Objekte, wie Waffen oder eine Hand, die auf etwas zeigen soll, handeln.
Axis gibt an, in welche Richtung das Objekt zielt.
Wenn zum Beispiel ein Laserpointer den Laser in Richtung der Z-Achse abstrahlt, muss die Achse auf (0,0,1) gesetzt werden, da das Schema (x,y,z) ist.
Damit die richtigen Knochen bewegt werden, wenn auf ein Ziel gezielt wird, müssen diese bei Bones definiert werden.
Das Wight steuert, wie stark die Veränderungen des Scripts auf die tatsächliche Position des Knochen einwirken sollen.
Bei 0 wird der Knochen kaum bis gar nicht verändert, wenn der Wert jedoch 1 ist, wird die ursprüngliche Position komplett verändert.
\begin {figure}
    \centering
    \includegraphics[scale=0.7]{pics/finalik_aimik_script}
    \caption{Final IK - AimIK Script}
    \label{fig:finalIK_aimIK_script}
\end {figure}
~\cite{FinalIK_AimIK_2021}

\subsection{Arm IK}\label{subsec:arm-ik}
ArmIK stellt die Position und Rotation der Knochen eines Armes so ein, dass die Hand möglichst nahe an der Zielposition platziert ist.
Hierfür werden 5 Knochen benötigt, Chest, Shoulder, Upper Arm, Forearm und Hand, siehe Abb. ~\ref{fig:finalIK_armIK_script}.
Chest befindet sich im Oberkörper des Modells und ist am nähesten am Arm dran.
Shoulder ist der Schulterknochen, Upper Arm ist der Oberarm Knochen, Forearm ist der Unterarm Knochen und Hand befindet sich in der Hand.
Hierbei werden die Finger nicht beachtet, da es sich nur um die Berechnung der Position des Armes handelt.
Mithilfe der Target Variable wird erneut ein Ziel festgelegt, welches die Zielposition der Hand angibt.
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/finalik_armik_script}
    \caption{Final IK - ArmIK Script}
    \label{fig:finalIK_armIK_script}
\end {figure}
~\cite{FinalIK_ArmIK_2021}

\subsection{Baker}\label{subsec:baker}
Der Baker ist ein Tool, welches die Aufnahme von Animations Clips ermöglicht.
Um humanoide Modelle aufzunehmen, muss das Humanoid Baker Script zu dem animierten Objekt hinzugefügt werden, siehe Abb. ~\ref{fig:finalIK_humanoid_baker}.
Für andere Modelle wird das Generic Baker Script benötigt, siehe Abb. ~\ref{fig:finalIK_generic_baker}.
Wenn die Applikation in Unity ausgeführt wird, kann in beiden Scripten auf Bake Animation States gedrückt werden.
Nun werden die Animationen in einen vorher ausgewählten Ordner abgespeichert und können jederzeit wiederverwendet werden.

\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/finalik_baker_HumanoidBakerComponent}
    \caption{Final IK - Humanoid Baker}
    \label{fig:finalIK_humanoid_baker}
\end {figure}
\begin {figure}
    \centering
    \includegraphics[scale=1]{pics/finalik_baker_GenericBakerComponent}
    \caption{Final IK - Generic Baker}
    \label{fig:finalIK_generic_baker}
\end {figure}
~\cite{FinalIK_Baker_2021}

\subsection{Biped IK}\label{subsec:biped-ik}
Biped IK erlaubt die Modifikation der Position und Rotation der Knochen eines Modelles mit 2 Beinen, 2 Armen und einem Kopf.
Das Script erkennt die Knochen automatisch und ist sofort einsatzbereit.
Seit FinalIK 4.0 wird jedoch FullBodyBiped IK empfohlen, da dieses eine leichtere Optimierung der IK eines Modelles erlaubt.

Es können wie bei vorherigen Funktionen Animationen beliebig überschrieben werden, ohne diese tatsächlich ändern zu müssen.
BipedIK bietet die Möglichkeit, jedes Glied, also Kopf, Füße, Arme, Ober- und Unterkörper, einzeln einzustellen, siehe Abb. ~\ref{fig:finalIK_bipedik_script}.
Weiters kann wieder ein Ziel festgelegt werden, falls der Charakter auf einen Gegenstand zielen soll.
\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/finalik_bipedik_script}
    \caption{Final IK - BipedIK Script}
    \label{fig:finalIK_bipedik_script}
\end {figure}
~\cite{FinalIK_BipedIK_2021}

\subsection{CCD IK}\label{subsec:ccd-ik}
Cyclic Coordinate Descent, auch als CCD bezeichnet, ist ein viel genutzter und bekannter Anwendungsfall von IK.
Dieses Script richtet die einzelnen Gelenke nacheinander in Richtung der Zielposition aus.
Durch das ständige Wiederholen dieser Aktion wird die Kette an Gelenken und Knochen richtig ausgerichtet.
Damit die Gelenke nicht unnatürliche Positionen einnehmen, kann ein Rotationslimit festgelegt werden, dieses kann nicht überschritten werden und sorgt für zusätzlichen Realismus.
Für längere Ketten an Gelenken wird empfohlen, FABRIK zu verwenden.
Ein Anwendungsfall für dieses Skript ist zum Beispiel ein Roboter oder andere Lebewesen, welche auf einem unebenen Gelände mit ihren Beinen auf dem Boden stehen sollen, siehe Abb. ~\ref{fig:finalIK_ccd_robot_example}.
Mit CCD ist es möglich die Beine so auszurichten, dass der Boden mit allen Gliedern berührt wird, ohne die Animationen anpassen zu müssen.
\begin {figure}
    \centering
    \includegraphics[scale=0.4]{pics/finalik_ccd}
    \caption{Final IK - CCD Robot Example}
    \label{fig:finalIK_ccd_robot_example}
\end {figure}
~\cite{FinalIK_CCD_2021}

\subsection{FABRIK}\label{subsec:fabrik}
Fabrik kann auf einer beliebigen Anzahl an Knochen-Segmenten mit Rotations-Limits verwendet werden.
Es benutzt eine Methode welche die neue Position von Gelenken in beide Richtungen, also Vorwärts und Rückwerts,
von einem Gelenk zum nächsten, berechnen kann.

Ein Vorteil von FABRIK ist, dass die Knochenlängen während der Laufzeit verändert werden können,
die Änderungen werden automatisch erkannt und neu berechnet. Ein Anwendungsfall für Fabrik ist in Abb. ~\ref{fig:finalIK_fabrik_example} zu sehen.
\begin {figure}
    \centering
    \includegraphics[scale=0.4]{pics/finalik_fabrik_pose}
    \caption{Final IK - Fabrik Example}
    \label{fig:finalIK_fabrik_example}
\end {figure}

Damit Fabrik benutzt werden kann, werden mehrere Variablen benötigt, siehe Abb. ~\ref{fig:finalIK_fabrik_script}.
Target, beschreibt die Position eines Zieles, zu welchem sich der Arm bewegen soll.
Die Position aller Knochen und Gelenke richtet sich automatisch so aus, dass der Arm auf das Ziel zeigt.

Weight kann dazu benutzt werden, um die Änderungen von Fabrik ein- und auszublenden. Ein Wert von 1 bedeutet,
dass alle Änderungen mit voller Kraft vorgenommen werden, wird der Wert nun näher an 0 gesetzt,
werden die Effekte nicht mehr übernommen.

Tolerance gibt die minimale Distanz an, welche die Zielposition bewegt werden muss,
bevor Fabrik die Berechnung aller Gelenke erneut startet. Liegt die Positionsänderung unter dem
Toleranzbereich wird nichts unternommen.

MaxIterations gibt die maximale Anzahl an Iterationen, welche in einem Frame durchgeführt werden dürfen.
Während den Iterationen wird die Position der Knochen und Gelenke berechnet.

UseRotationLimits gibt an, ob die Rotationslimits auf den Einzelnen Knochen bei der Berechnung der Position
miteinbezogen werden sollen, oder nicht.

Bei Bones, handelt es sich um eine Liste, welche alle Knochen beinhalten soll, die bei der Berechnung der
Positionen und Rotationen, herangezogen werden sollen.
~\cite{FinalIK_FABRIK_2021}
\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/finalik_fabrik_script}
    \caption{Final IK - Fabrik Script}
    \label{fig:finalIK_fabrik_script}
\end {figure}


\subsection{FABRIK Root}\label{subsec:fabrik-root}


Fabrik Root ist ein Component, welcher mehrere einzelne Fabrik Ketten miteinander verbinden lässt.
Hierbei kann es sich um kompliziertere Systeme mit mehreren Abzweigungen handeln, siehe Abb. ~\ref{fig:finalIK_fabrik_root_example}

\begin {figure}
    \centering
    \includegraphics[scale=0.8]{pics/finalik_fabrik_root_example}
    \caption{Final IK - Fabrik Root Script}
    \label{fig:finalIK_fabrik_root_example}
\end {figure}


Damit Fabrik Root richtig funktioniert müssen, ähnlich wie bei Fabrik, verschiedene Variablen angegeben werden,
siehe Abb. ~\ref{fig:finalIK_fabrik_root_script}.

Weight wird benutzt, um die Änderungen von FabrikRoot und Fabrik ein- und auszublenden.
Ein Wert von 1 bedeutet, dass alle Änderungen mit voller Kraft vorgenommen werden, wird der Wert nun auf 0 gesetzt,
werden die Effekte nicht mehr übernommen.

Iterations gibt die Anzahl an Iterationen, welche in einem Frame durchgeführt werden dürfen, an.
Hierbei wird in jeder Iteration die Position und Rotation aller angegebenen Fabrik Ketten berechnet.

RootPin befestigt die Fabrik Ketten an einen Bestimmten Ort, welcher zum Beispiel auf einem Objekt,
oder irgendwo in der Luft platziert werden kann. Dieser Punkt kann nicht durch die Fabrik Ketten bewegt werden.

Chains ist eine Liste an Fabrik.
IK gibt den Fabrik Komponent an, welcher die Position und Rotation einer Knochenkette berechnet.

Pull gibt an wie stark diese Kette die, in der Hierarchie übergestellte, Kette bewegen darf.

Pin gibt an, wie stark die Kette von einer Kette, welche in der Hierarchie untergeordnet ist, bewegt werden kann.

Children ist eine Liste von Indizes, welche auf die, in der Hierarchie untergeordneten, Fabrik verweist.

\begin {figure}
    \centering
    \includegraphics[scale=0.5]{pics/finalik_fabrik_root_script}
    \caption{Final IK - Fabrik Root Script}
    \label{fig:finalIK_fabrik_root_script}
\end {figure}

\subsection{Full Body Biped IK}\label{subsec:full-body-biped-ik}
Die Full Body Biped IK ist eine flexible und schnelle Lösung für Biped Charaktere, darunter Fallen Modelle, welche zum Beispiel auf zwei Beinen stehen.
Der Charakter wird auf ein simples IK-Rig reduziert, von welchem die Position und Rotation der einzelnen Gliedmaßen berechnet wird.
Die Berechnung wird dabei in jedem Frame durchgeführt.
Das Ergebnis danach wieder auf das 3D Modell übertragen, siehe Abb. ~\ref{fig:finalIK_full_body_biped_ik}.
~\cite{FinalIK_FullBodyBipedIK_2021}

\begin {figure}
    \centering
    \includegraphics[scale=0.5]{pics/fullbodybipedIK}
    \caption{Final IK - FullBodyBiped IK}
    \label{fig:finalIK_full_body_biped_ik}
\end {figure}
